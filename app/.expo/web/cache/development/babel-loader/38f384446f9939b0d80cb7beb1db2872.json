{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { EventEmitter } from '@unimodules/core';\n\nvar GeocoderError = function (_Error) {\n  _inherits(GeocoderError, _Error);\n\n  var _super = _createSuper(GeocoderError);\n\n  function GeocoderError() {\n    var _this;\n\n    _classCallCheck(this, GeocoderError);\n\n    _this = _super.call(this, 'Geocoder service is not available for this device.');\n    _this.code = 'E_NO_GEOCODER';\n    return _this;\n  }\n\n  return _createClass(GeocoderError);\n}(_wrapNativeSuper(Error));\n\nvar emitter = new EventEmitter({});\n\nfunction positionToJSON(position) {\n  if (!position) return null;\n  var _position$coords = position.coords,\n      coords = _position$coords === void 0 ? {} : _position$coords,\n      timestamp = position.timestamp;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp: timestamp\n  };\n}\n\nexport default {\n  get name() {\n    return 'ExpoLocation';\n  },\n\n  getProviderStatusAsync: function () {\n    var _getProviderStatusAsync = _asyncToGenerator(function* () {\n      return {\n        locationServicesEnabled: 'geolocation' in navigator\n      };\n    });\n\n    function getProviderStatusAsync() {\n      return _getProviderStatusAsync.apply(this, arguments);\n    }\n\n    return getProviderStatusAsync;\n  }(),\n  getCurrentPositionAsync: function () {\n    var _getCurrentPositionAsync = _asyncToGenerator(function* (options) {\n      return new Promise(function (resolve, reject) {\n        return navigator.geolocation.getCurrentPosition(function (position) {\n          return resolve(positionToJSON(position));\n        }, reject, options);\n      });\n    });\n\n    function getCurrentPositionAsync(_x) {\n      return _getCurrentPositionAsync.apply(this, arguments);\n    }\n\n    return getCurrentPositionAsync;\n  }(),\n  removeWatchAsync: function () {\n    var _removeWatchAsync = _asyncToGenerator(function* (watchId) {\n      navigator.geolocation.clearWatch(watchId);\n    });\n\n    function removeWatchAsync(_x2) {\n      return _removeWatchAsync.apply(this, arguments);\n    }\n\n    return removeWatchAsync;\n  }(),\n  watchDeviceHeading: function () {\n    var _watchDeviceHeading = _asyncToGenerator(function* (headingId) {\n      console.warn('Location.watchDeviceHeading: is not supported on web');\n    });\n\n    function watchDeviceHeading(_x3) {\n      return _watchDeviceHeading.apply(this, arguments);\n    }\n\n    return watchDeviceHeading;\n  }(),\n  hasServicesEnabledAsync: function () {\n    var _hasServicesEnabledAsync = _asyncToGenerator(function* () {\n      return 'geolocation' in navigator;\n    });\n\n    function hasServicesEnabledAsync() {\n      return _hasServicesEnabledAsync.apply(this, arguments);\n    }\n\n    return hasServicesEnabledAsync;\n  }(),\n  geocodeAsync: function () {\n    var _geocodeAsync = _asyncToGenerator(function* () {\n      throw new GeocoderError();\n    });\n\n    function geocodeAsync() {\n      return _geocodeAsync.apply(this, arguments);\n    }\n\n    return geocodeAsync;\n  }(),\n  reverseGeocodeAsync: function () {\n    var _reverseGeocodeAsync = _asyncToGenerator(function* () {\n      throw new GeocoderError();\n    });\n\n    function reverseGeocodeAsync() {\n      return _reverseGeocodeAsync.apply(this, arguments);\n    }\n\n    return reverseGeocodeAsync;\n  }(),\n  watchPositionImplAsync: function () {\n    var _watchPositionImplAsync = _asyncToGenerator(function* (watchId, options) {\n      return new Promise(function (resolve) {\n        watchId = global.navigator.geolocation.watchPosition(function (location) {\n          emitter.emit('Expo.locationChanged', {\n            watchId: watchId,\n            location: positionToJSON(location)\n          });\n        }, null, options);\n        resolve(watchId);\n      });\n    });\n\n    function watchPositionImplAsync(_x4, _x5) {\n      return _watchPositionImplAsync.apply(this, arguments);\n    }\n\n    return watchPositionImplAsync;\n  }(),\n  requestPermissionsAsync: function () {\n    var _requestPermissionsAsync = _asyncToGenerator(function* () {\n      return new Promise(function (resolve) {\n        navigator.geolocation.getCurrentPosition(function () {\n          return resolve({\n            status: 'granted'\n          });\n        }, function (_ref) {\n          var code = _ref.code;\n\n          if (code === 1) {\n            resolve({\n              status: 'denied'\n            });\n          } else {\n            resolve({\n              status: 'undetermined'\n            });\n          }\n        });\n      });\n    });\n\n    function requestPermissionsAsync() {\n      return _requestPermissionsAsync.apply(this, arguments);\n    }\n\n    return requestPermissionsAsync;\n  }()\n};","map":{"version":3,"sources":["../src/ExpoLocation.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from '@unimodules/core';\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\n\ninterface Position {\n  coords: Coordinates;\n  timestamp: number;\n}\n\ninterface PermissionResult {\n  status: string;\n}\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\nconst emitter = new EventEmitter({} as any);\n\nfunction positionToJSON(position: any): Position | null {\n  if (!position) return null;\n\n  const { coords = {}, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getCurrentPositionAsync(options: object): Promise<Position | null> {\n    return new Promise<Position | null>((resolve, reject) =>\n      navigator.geolocation.getCurrentPosition(\n        position => resolve(positionToJSON(position)),\n        reject,\n        options\n      )\n    );\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: object): Promise<string> {\n    return new Promise<string>(resolve => {\n      // @ts-ignore\n      watchId = global.navigator.geolocation.watchPosition(\n        location => {\n          emitter.emit('Expo.locationChanged', { watchId, location: positionToJSON(location) });\n        },\n        null,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n  async requestPermissionsAsync(): Promise<PermissionResult> {\n    return new Promise<PermissionResult>(resolve => {\n      navigator.geolocation.getCurrentPosition(\n        () => resolve({ status: 'granted' }),\n        ({ code }) => {\n          if (code === 1 /* PERMISSION_DENIED */) {\n            resolve({ status: 'denied' });\n          } else {\n            resolve({ status: 'undetermined' });\n          }\n        }\n      );\n    });\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}