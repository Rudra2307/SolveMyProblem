{"ast":null,"code":"import { ExecutionEnvironment } from 'expo-constants';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nvar originalNativeModules = NativeModules;\nvar PROPS_TO_IGNORE = new Set(['DevLoadingView', 'EXDevLauncher', 'EXReactNativeEventEmitter', 'NativeUnimoduleProxy', 'ExpoImageModule', 'ExpoRandom', 'PlatformLocalStorage', 'RNC_AsyncSQLiteDBStorage', 'RNCAsyncStorage', 'RNGetRandomValues', 'RNVectorIconsManager', 'RNVectorIconsModule', 'LottieAnimationViewManager', 'LottieAnimationView', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toJSON', 'toLocaleString', 'toString', 'valueOf', '$$typeof']);\nvar alreadyErroredModules = new Set();\nvar additionalModulesToIgnore = new Set();\nvar enabled = true;\n\nfunction createErrorMessageForStoreClient(moduleName) {\n  return \"Your JavaScript code tried to access a native module, \" + moduleName + \", that isn't supported in Expo Go.\\nTo continue development with \" + moduleName + \", you need to create a development build of your app. See https://expo.fyi/missing-native-module for more info, including how to disable these errors.\";\n}\n\nfunction createErrorMessageForDevelopmentBuild(moduleName) {\n  return \"Your JavaScript code tried to access a native module, \" + moduleName + \", that doesn't exist in this development build.\\nMake sure you are using the newest available development build of this app and running a compatible version of your JavaScript code. If you've installed a new library recently, you may need to make a new development build.\\nSee https://expo.fyi/missing-native-module for more info, including how to disable these errors.\";\n}\n\nexport function createProxyForNativeModules(NativeModules) {\n  if (!__DEV__) {\n    return NativeModules;\n  }\n\n  return new Proxy(NativeModules, {\n    get: function get(target, prop, receiver) {\n      var value = Reflect.get(target, prop, receiver);\n\n      if (enabled && typeof prop !== 'symbol' && (value === null || value === undefined) && !PROPS_TO_IGNORE.has(prop) && !additionalModulesToIgnore.has(prop) && !alreadyErroredModules.has(prop)) {\n        var _global$expo, _global$expo$modules, _global$expo$modules$, _global$expo$modules$2, _target$NativeUnimodu, _target$NativeUnimodu2;\n\n        alreadyErroredModules.add(prop);\n        var isRunningInStoreClient = ((_global$expo = global.expo) == null ? void 0 : (_global$expo$modules = _global$expo.modules) == null ? void 0 : (_global$expo$modules$ = _global$expo$modules.NativeModulesProxy) == null ? void 0 : (_global$expo$modules$2 = _global$expo$modules$.modulesConstants.ExponentConstants) == null ? void 0 : _global$expo$modules$2.executionEnvironment) === ExecutionEnvironment.StoreClient || ((_target$NativeUnimodu = target.NativeUnimoduleProxy) == null ? void 0 : (_target$NativeUnimodu2 = _target$NativeUnimodu.modulesConstants.ExponentConstants) == null ? void 0 : _target$NativeUnimodu2.executionEnvironment) === ExecutionEnvironment.StoreClient;\n\n        if (isRunningInStoreClient) {\n          throw new Error(createErrorMessageForStoreClient(prop));\n        } else if (target.EXDevLauncher) {\n          throw new Error(createErrorMessageForDevelopmentBuild(prop));\n        }\n      }\n\n      return value;\n    }\n  });\n}\nexport function disableMissingNativeModuleErrors(moduleNames) {\n  if (moduleNames) {\n    additionalModulesToIgnore = typeof moduleNames === 'string' ? new Set([moduleNames]) : new Set(moduleNames);\n    enabled = true;\n  } else {\n    enabled = false;\n  }\n}\nexport function getNativeModuleIfExists(moduleName) {\n  return originalNativeModules[moduleName];\n}","map":{"version":3,"sources":["../../src/proxies/NativeModules.ts"],"names":[],"mappings":"AAAA,SAAS,oBAAT,QAAqC,gBAArC;;AAGA,IAAM,qBAAqB,GAAG,aAA9B;AAEA,IAAM,eAAe,GAAgB,IAAI,GAAJ,CAAQ,CAK3C,gBAL2C,EAM3C,eAN2C,EAO3C,2BAP2C,EAQ3C,sBAR2C,EAY3C,iBAZ2C,EAa3C,YAb2C,EAc3C,sBAd2C,EAe3C,0BAf2C,EAgB3C,iBAhB2C,EAiB3C,mBAjB2C,EAkB3C,sBAlB2C,EAmB3C,qBAnB2C,EAqB3C,4BArB2C,EAsB3C,qBAtB2C,EA4B3C,gBA5B2C,EA6B3C,eA7B2C,EA8B3C,sBA9B2C,EA+B3C,QA/B2C,EAgC3C,gBAhC2C,EAiC3C,UAjC2C,EAkC3C,SAlC2C,EAmC3C,UAnC2C,CAAR,CAArC;AAqCA,IAAM,qBAAqB,GAAgB,IAAI,GAAJ,EAA3C;AAEA,IAAI,yBAAyB,GAAgB,IAAI,GAAJ,EAA7C;AACA,IAAI,OAAO,GAAG,IAAd;;AAEA,SAAS,gCAAT,CAA0C,UAA1C,EAA4D;AAC1D,oEAAgE,UAAhE,yEAC6B,UAD7B;AAED;;AAED,SAAS,qCAAT,CAA+C,UAA/C,EAAiE;AAC/D,oEAAgE,UAAhE;AAGD;;AAED,OAAM,SAAU,2BAAV,CAAsC,aAAtC,EAAwD;AAC5D,MAAI,CAAC,OAAL,EAAc;AACZ,WAAO,aAAP;AACD;;AACD,SAAO,IAAI,KAAJ,CAAU,aAAV,EAAyB;AAC9B,IAAA,GAD8B,eAC1B,MAD0B,EAClB,IADkB,EACZ,QADY,EACJ;AACxB,UAAM,KAAK,GAAG,OAAO,CAAC,GAAR,CAAY,MAAZ,EAAoB,IAApB,EAA0B,QAA1B,CAAd;;AACA,UACE,OAAO,IACP,OAAO,IAAP,KAAgB,QADhB,KAEC,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,SAF7B,KAGA,CAAC,eAAe,CAAC,GAAhB,CAAoB,IAApB,CAHD,IAIA,CAAC,yBAAyB,CAAC,GAA1B,CAA8B,IAA9B,CAJD,IAKA,CAAC,qBAAqB,CAAC,GAAtB,CAA0B,IAA1B,CANH,EAOE;AAAA;;AACA,QAAA,qBAAqB,CAAC,GAAtB,CAA0B,IAA1B;AAEA,YAAM,sBAAsB,GAC1B,iBAAA,MAAM,CAAC,IAAP,0DAAa,OAAb,mEAAsB,kBAAtB,qEAA0C,gBAA1C,CAA2D,iBAA3D,4CACI,oBADJ,MAC6B,oBAAoB,CAAC,WADlD,IAEA,0BAAA,MAAM,CAAC,oBAAP,qEAA6B,gBAA7B,CAA8C,iBAA9C,4CAAiE,oBAAjE,MACE,oBAAoB,CAAC,WAJzB;;AAKA,YAAI,sBAAJ,EAA4B;AAC1B,gBAAM,IAAI,KAAJ,CAAU,gCAAgC,CAAC,IAAD,CAA1C,CAAN;AACD,SAFD,MAEO,IAAI,MAAM,CAAC,aAAX,EAA0B;AAC/B,gBAAM,IAAI,KAAJ,CAAU,qCAAqC,CAAC,IAAD,CAA/C,CAAN;AACD;AACF;;AACD,aAAO,KAAP;AACD;AAzB6B,GAAzB,CAAP;AA2BD;AAWD,OAAM,SAAU,gCAAV,CAA2C,WAA3C,EAA0E;AAC9E,MAAI,WAAJ,EAAiB;AACf,IAAA,yBAAyB,GACvB,OAAO,WAAP,KAAuB,QAAvB,GAAkC,IAAI,GAAJ,CAAQ,CAAC,WAAD,CAAR,CAAlC,GAA2D,IAAI,GAAJ,CAAQ,WAAR,CAD7D;AAEA,IAAA,OAAO,GAAG,IAAV;AACD,GAJD,MAIO;AACL,IAAA,OAAO,GAAG,KAAV;AACD;AACF;AAQD,OAAM,SAAU,uBAAV,CAAkC,UAAlC,EAAoD;AACxD,SAAO,qBAAqB,CAAC,UAAD,CAA5B;AACD","sourcesContent":["import { ExecutionEnvironment } from 'expo-constants';\nimport { NativeModules } from 'react-native';\n\nconst originalNativeModules = NativeModules;\n\nconst PROPS_TO_IGNORE: Set<string> = new Set([\n  /**\n   * We don't want to throw when the expo or expo-modules-core packages try to access any of these\n   * modules, since they have built-in fallbacks.\n   */\n  'DevLoadingView',\n  'EXDevLauncher',\n  'EXReactNativeEventEmitter',\n  'NativeUnimoduleProxy',\n  /**\n   * Other modules that are accessed via packages in the Expo SDK but have built-in fallbacks\n   */\n  'ExpoImageModule',\n  'ExpoRandom',\n  'PlatformLocalStorage',\n  'RNC_AsyncSQLiteDBStorage',\n  'RNCAsyncStorage',\n  'RNGetRandomValues',\n  'RNVectorIconsManager',\n  'RNVectorIconsModule',\n  // False alarm from lottie where it uses react-native-safe-module to detect corresponding native module, but it doesn't exist in lottie.\n  'LottieAnimationViewManager',\n  'LottieAnimationView',\n  /**\n   * Other methods that can be called on the NativeModules object that we should ignore. The\n   * underlying NativeModules object is sometimes a proxy itself so may not have these methods\n   * defined.\n   */\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toJSON',\n  'toLocaleString',\n  'toString',\n  'valueOf',\n  '$$typeof',\n]);\nconst alreadyErroredModules: Set<string> = new Set();\n\nlet additionalModulesToIgnore: Set<string> = new Set();\nlet enabled = true;\n\nfunction createErrorMessageForStoreClient(moduleName: string) {\n  return `Your JavaScript code tried to access a native module, ${moduleName}, that isn't supported in Expo Go.\nTo continue development with ${moduleName}, you need to create a development build of your app. See https://expo.fyi/missing-native-module for more info, including how to disable these errors.`;\n}\n\nfunction createErrorMessageForDevelopmentBuild(moduleName: string) {\n  return `Your JavaScript code tried to access a native module, ${moduleName}, that doesn't exist in this development build.\nMake sure you are using the newest available development build of this app and running a compatible version of your JavaScript code. If you've installed a new library recently, you may need to make a new development build.\nSee https://expo.fyi/missing-native-module for more info, including how to disable these errors.`;\n}\n\nexport function createProxyForNativeModules(NativeModules: any) {\n  if (!__DEV__) {\n    return NativeModules;\n  }\n  return new Proxy(NativeModules, {\n    get(target, prop, receiver) {\n      const value = Reflect.get(target, prop, receiver);\n      if (\n        enabled &&\n        typeof prop !== 'symbol' &&\n        (value === null || value === undefined) &&\n        !PROPS_TO_IGNORE.has(prop) &&\n        !additionalModulesToIgnore.has(prop) &&\n        !alreadyErroredModules.has(prop)\n      ) {\n        alreadyErroredModules.add(prop);\n\n        const isRunningInStoreClient =\n          global.expo?.modules?.NativeModulesProxy?.modulesConstants.ExponentConstants\n            ?.executionEnvironment === ExecutionEnvironment.StoreClient ||\n          target.NativeUnimoduleProxy?.modulesConstants.ExponentConstants?.executionEnvironment ===\n            ExecutionEnvironment.StoreClient;\n        if (isRunningInStoreClient) {\n          throw new Error(createErrorMessageForStoreClient(prop));\n        } else if (target.EXDevLauncher) {\n          throw new Error(createErrorMessageForDevelopmentBuild(prop));\n        }\n      }\n      return value;\n    },\n  });\n}\n\n/**\n * Disable the error thrown when trying to access a native module that doesn't exist in the host\n * runtime. If a module name or array of module names is provided, this method disables the error\n * for only those modules, erasing a previous setting if one exists. If no parameter is provided,\n * this method disables the error for all modules.\n *\n * @param moduleNames Name of module or modules for which to disable the missing native module\n * error. If this parameter is omitted, the error will be disabled globally.\n */\nexport function disableMissingNativeModuleErrors(moduleNames?: string[] | string) {\n  if (moduleNames) {\n    additionalModulesToIgnore =\n      typeof moduleNames === 'string' ? new Set([moduleNames]) : new Set(moduleNames);\n    enabled = true;\n  } else {\n    enabled = false;\n  }\n}\n\n/**\n * Access a native module without throwing an error if it doesn't exist.\n *\n * @param moduleName Name of module to access\n * @returns Corresponding native module object, or null if it doesn't exist\n */\nexport function getNativeModuleIfExists(moduleName: string): any {\n  return originalNativeModules[moduleName];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}