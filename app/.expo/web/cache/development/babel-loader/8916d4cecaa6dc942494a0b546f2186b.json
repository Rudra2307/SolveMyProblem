{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport * as NavigationActions from \"../NavigationActions\";\nimport * as SwitchActions from \"./SwitchActions\";\nimport * as StackActions from \"./StackActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport { createPathParser } from \"./pathUtils\";\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(function (n) {\n      return \"\\\"\".concat(n, \"\\\"\");\n    }).join(', ')));\n  }\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    childRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n  function getParamsForRoute(routeName, params) {\n    var routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, {}, params);\n    } else {\n      return params;\n    }\n  }\n  var _createPathParser = createPathParser(childRouters, routeConfigs, config),\n    getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n    _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n  function resetChildRoute(routeName) {\n    var initialParams = routeName === initialRouteName ? initialRouteParams : undefined;\n\n    var params = getParamsForRoute(routeName, initialParams);\n    var childRouter = childRouters[routeName];\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName: routeName,\n        params: params\n      });\n    }\n    return {\n      key: routeName,\n      routeName: routeName,\n      params: params\n    };\n  }\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n      var nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n\n        var keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(function (k) {\n          return k !== keyToAdd;\n        });\n\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n\n        nextRouteKeyHistory.pop();\n      }\n      return _objectSpread({}, nextState, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n    var nextState = possibleNextState;\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      var prevRouteName = prevState.routes[prevState.index].routeName;\n      var nextRoutes = _toConsumableArray(possibleNextState.routes);\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread({}, possibleNextState, {\n        routes: nextRoutes\n      });\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n  function getInitialState() {\n    var routes = order.map(resetChildRoute);\n    var initialState = {\n      routes: routes,\n      index: initialRouteIndex\n    };\n    if (backBehavior === 'history') {\n      var initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n  return {\n    childRouters: childRouters,\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || getInitialState();\n      var activeChildIndex = state.index;\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, {}, params, {}, route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        var _params = action.params;\n        var index = state.routes.findIndex(function (route) {\n          return route.routeName === action.routeName;\n        });\n        if (index === -1) {\n          throw new Error(\"There is no route named '\".concat(action.routeName, \"' in the navigator with the key '\").concat(action.key, \"'.\\n\") + \"Must be one of: \".concat(state.routes.map(function (route) {\n            return \"'\".concat(route.routeName, \"'\");\n          }).join(',')));\n        }\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          routes: _params ? state.routes.map(function (route, i) {\n            return i === index ? _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, {}, _params)\n            }) : route;\n          }) : state.routes,\n          index: index\n        }));\n      }\n\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var routes = _toConsumableArray(state.routes);\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: routes\n          }));\n        }\n      }\n\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          var routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n      var didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState = childState;\n          if (action.action && childRouter) {\n            var childStateUpdate = childRouter.getStateForAction(action.action, childState);\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n          if (action.params) {\n            newChildState = _objectSpread({}, newChildState, {\n              params: _objectSpread({}, newChildState.params || {}, {}, action.params)\n            });\n          }\n          if (newChildState !== childState) {\n            var _routes = _toConsumableArray(state.routes);\n            _routes[activeChildIndex] = newChildState;\n            var nextState = _objectSpread({}, state, {\n              routes: _routes,\n              index: activeChildIndex\n            });\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n        if (lastRoute) {\n          var _params2 = _objectSpread({}, lastRoute.params, {}, action.params);\n          var _routes2 = _toConsumableArray(state.routes);\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: _params2\n          });\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes2\n          }));\n        }\n      }\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n      var isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      var sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null;\n\n      if (sendActionToInactiveChildren) {\n        var _index = state.index;\n        var _routes3 = state.routes;\n        order.find(function (childId, i) {\n          var childRouter = childRouters[childId];\n          if (i === _index) {\n            return false;\n          }\n          var childState = _routes3[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            _index = i;\n            return true;\n          }\n          if (childState !== _routes3[i]) {\n            _routes3 = _toConsumableArray(_routes3);\n            _routes3[i] = childState;\n            _index = i;\n            return true;\n          }\n          return false;\n        });\n\n        if (action.preserveFocus) {\n          _index = state.index;\n        }\n        if (_index !== state.index || _routes3 !== state.routes) {\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            index: _index,\n            routes: _routes3\n          }));\n        }\n      }\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      var childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"sources":["SwitchRouter.js"],"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","SwitchActions","StackActions","validateRouteConfigMap","createPathParser","defaultActionCreators","routeConfigs","config","order","Object","keys","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","map","n","join","childRouters","forEach","routeName","screen","router","getParamsForRoute","params","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","undefined","childRouter","childAction","init","getStateForAction","key","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","index","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","keyToAdd","routes","filter","k","push","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","JUMP_TO","findIndex","i","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","length","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","SET_PARAMS","lastRoute","isActionBackOrPop","POP","POP_TO_TOP","sendActionToInactiveChildren","preserveFocus","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map((n) => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach((routeName) => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (\n        backBehavior !== 'history' ||\n        (prevState && nextState && nextState.index === prevState.index)\n      ) {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter((k) => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      possibleNextState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map((route) => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          (route) => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${action.routeName}' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map((route) => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: params\n            ? state.routes.map((route, i) =>\n                i === index\n                  ? {\n                      ...route,\n                      params: {\n                        ...route.params,\n                        ...params,\n                      },\n                    }\n                  : route\n              )\n            : state.routes,\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      const isActionBackOrPop =\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP ||\n        action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren =\n        !isActionBackOrPop ||\n        (action.type === NavigationActions.BACK && action.key != null);\n\n      // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n          if (i === index) {\n            return false;\n          }\n          let childState = routes[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            index = i;\n            return true;\n          }\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n          return false;\n        });\n\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, {\n            ...state,\n            index,\n            routes,\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}