{"ast":null,"code":"import { ExecutionEnvironment } from 'expo-constants';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nvar originalNativeModules = NativeModules;\nvar PROPS_TO_IGNORE = new Set([\n'DevLoadingView', 'EXDevLauncher', 'EXReactNativeEventEmitter', 'NativeUnimoduleProxy',\n'ExpoImageModule', 'ExpoRandom', 'PlatformLocalStorage', 'RNC_AsyncSQLiteDBStorage', 'RNCAsyncStorage', 'RNGetRandomValues', 'RNVectorIconsManager', 'RNVectorIconsModule',\n'LottieAnimationViewManager', 'LottieAnimationView',\n'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toJSON', 'toLocaleString', 'toString', 'valueOf', '$$typeof']);\nvar alreadyErroredModules = new Set();\nvar additionalModulesToIgnore = new Set();\nvar enabled = true;\nfunction createErrorMessageForStoreClient(moduleName) {\n  return \"Your JavaScript code tried to access a native module, \" + moduleName + \", that isn't supported in Expo Go.\\nTo continue development with \" + moduleName + \", you need to create a development build of your app. See https://expo.fyi/missing-native-module for more info, including how to disable these errors.\";\n}\nfunction createErrorMessageForDevelopmentBuild(moduleName) {\n  return \"Your JavaScript code tried to access a native module, \" + moduleName + \", that doesn't exist in this development build.\\nMake sure you are using the newest available development build of this app and running a compatible version of your JavaScript code. If you've installed a new library recently, you may need to make a new development build.\\nSee https://expo.fyi/missing-native-module for more info, including how to disable these errors.\";\n}\nexport function createProxyForNativeModules(NativeModules) {\n  if (!__DEV__) {\n    return NativeModules;\n  }\n  return new Proxy(NativeModules, {\n    get: function get(target, prop, receiver) {\n      var value = Reflect.get(target, prop, receiver);\n      if (enabled && typeof prop !== 'symbol' && (value === null || value === undefined) && !PROPS_TO_IGNORE.has(prop) && !additionalModulesToIgnore.has(prop) && !alreadyErroredModules.has(prop)) {\n        var _global$expo, _global$expo$modules, _global$expo$modules$, _global$expo$modules$2, _target$NativeUnimodu, _target$NativeUnimodu2;\n        alreadyErroredModules.add(prop);\n        var isRunningInStoreClient = ((_global$expo = global.expo) == null ? void 0 : (_global$expo$modules = _global$expo.modules) == null ? void 0 : (_global$expo$modules$ = _global$expo$modules.NativeModulesProxy) == null ? void 0 : (_global$expo$modules$2 = _global$expo$modules$.modulesConstants.ExponentConstants) == null ? void 0 : _global$expo$modules$2.executionEnvironment) === ExecutionEnvironment.StoreClient || ((_target$NativeUnimodu = target.NativeUnimoduleProxy) == null ? void 0 : (_target$NativeUnimodu2 = _target$NativeUnimodu.modulesConstants.ExponentConstants) == null ? void 0 : _target$NativeUnimodu2.executionEnvironment) === ExecutionEnvironment.StoreClient;\n        if (isRunningInStoreClient) {\n          throw new Error(createErrorMessageForStoreClient(prop));\n        } else if (target.EXDevLauncher) {\n          throw new Error(createErrorMessageForDevelopmentBuild(prop));\n        }\n      }\n      return value;\n    }\n  });\n}\nexport function disableMissingNativeModuleErrors(moduleNames) {\n  if (moduleNames) {\n    additionalModulesToIgnore = typeof moduleNames === 'string' ? new Set([moduleNames]) : new Set(moduleNames);\n    enabled = true;\n  } else {\n    enabled = false;\n  }\n}\nexport function getNativeModuleIfExists(moduleName) {\n  return originalNativeModules[moduleName];\n}","map":{"version":3,"mappings":"AAAA,SAASA,oBAAoB,QAAQ,gBAAgB;AAAC;AAGtD,IAAMC,qBAAqB,GAAGC,aAAa;AAE3C,IAAMC,eAAe,GAAgB,IAAIC,GAAG,CAAC;AAK3C,gBAAgB,EAChB,eAAe,EACf,2BAA2B,EAC3B,sBAAsB;AAItB,iBAAiB,EACjB,YAAY,EACZ,sBAAsB,EACtB,0BAA0B,EAC1B,iBAAiB,EACjB,mBAAmB,EACnB,sBAAsB,EACtB,qBAAqB;AAErB,4BAA4B,EAC5B,qBAAqB;AAMrB,gBAAgB,EAChB,eAAe,EACf,sBAAsB,EACtB,QAAQ,EACR,gBAAgB,EAChB,UAAU,EACV,SAAS,EACT,UAAU,CACX,CAAC;AACF,IAAMC,qBAAqB,GAAgB,IAAID,GAAG,EAAE;AAEpD,IAAIE,yBAAyB,GAAgB,IAAIF,GAAG,EAAE;AACtD,IAAIG,OAAO,GAAG,IAAI;AAElB,SAASC,gCAAgC,CAACC,UAAkB;EAC1D,kEAAgEA,UAAU,yEAC7CA,UAAU;AACzC;AAEA,SAASC,qCAAqC,CAACD,UAAkB;EAC/D,kEAAgEA,UAAU;AAG5E;AAEA,OAAM,SAAUE,2BAA2B,CAACT,aAAkB;EAC5D,IAAI,CAACU,OAAO,EAAE;IACZ,OAAOV,aAAa;;EAEtB,OAAO,IAAIW,KAAK,CAACX,aAAa,EAAE;IAC9BY,GAAG,eAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;MACxB,IAAMC,KAAK,GAAGC,OAAO,CAACL,GAAG,CAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,CAAC;MACjD,IACEV,OAAO,IACP,OAAOS,IAAI,KAAK,QAAQ,KACvBE,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKE,SAAS,CAAC,IACvC,CAACjB,eAAe,CAACkB,GAAG,CAACL,IAAI,CAAC,IAC1B,CAACV,yBAAyB,CAACe,GAAG,CAACL,IAAI,CAAC,IACpC,CAACX,qBAAqB,CAACgB,GAAG,CAACL,IAAI,CAAC,EAChC;QAAA;QACAX,qBAAqB,CAACiB,GAAG,CAACN,IAAI,CAAC;QAE/B,IAAMO,sBAAsB,GAC1B,uBAAM,CAACC,IAAI,6CAAX,aAAaC,OAAO,8CAApB,qBAAsBC,kBAAkB,+CAAxC,sBAA0CC,gBAAgB,CAACC,iBAAiB,qBAA5E,uBACIC,oBAAoB,MAAK7B,oBAAoB,CAAC8B,WAAW,IAC7D,gCAAM,CAACC,oBAAoB,+CAA3B,sBAA6BJ,gBAAgB,CAACC,iBAAiB,qBAA/D,uBAAiEC,oBAAoB,MACnF7B,oBAAoB,CAAC8B,WAAW;QACpC,IAAIP,sBAAsB,EAAE;UAC1B,MAAM,IAAIS,KAAK,CAACxB,gCAAgC,CAACQ,IAAI,CAAC,CAAC;SACxD,MAAM,IAAID,MAAM,CAACkB,aAAa,EAAE;UAC/B,MAAM,IAAID,KAAK,CAACtB,qCAAqC,CAACM,IAAI,CAAC,CAAC;;;MAGhE,OAAOE,KAAK;IACd;GACD,CAAC;AACJ;AAWA,OAAM,SAAUgB,gCAAgC,CAACC,WAA+B;EAC9E,IAAIA,WAAW,EAAE;IACf7B,yBAAyB,GACvB,OAAO6B,WAAW,KAAK,QAAQ,GAAG,IAAI/B,GAAG,CAAC,CAAC+B,WAAW,CAAC,CAAC,GAAG,IAAI/B,GAAG,CAAC+B,WAAW,CAAC;IACjF5B,OAAO,GAAG,IAAI;GACf,MAAM;IACLA,OAAO,GAAG,KAAK;;AAEnB;AAQA,OAAM,SAAU6B,uBAAuB,CAAC3B,UAAkB;EACxD,OAAOR,qBAAqB,CAACQ,UAAU,CAAC;AAC1C","names":["ExecutionEnvironment","originalNativeModules","NativeModules","PROPS_TO_IGNORE","Set","alreadyErroredModules","additionalModulesToIgnore","enabled","createErrorMessageForStoreClient","moduleName","createErrorMessageForDevelopmentBuild","createProxyForNativeModules","__DEV__","Proxy","get","target","prop","receiver","value","Reflect","undefined","has","add","isRunningInStoreClient","expo","modules","NativeModulesProxy","modulesConstants","ExponentConstants","executionEnvironment","StoreClient","NativeUnimoduleProxy","Error","EXDevLauncher","disableMissingNativeModuleErrors","moduleNames","getNativeModuleIfExists"],"sourceRoot":"","sources":["../../src/proxies/NativeModules.ts"],"sourcesContent":["import { ExecutionEnvironment } from 'expo-constants';\nimport { NativeModules } from 'react-native';\n\nconst originalNativeModules = NativeModules;\n\nconst PROPS_TO_IGNORE: Set<string> = new Set([\n  /**\n   * We don't want to throw when the expo or expo-modules-core packages try to access any of these\n   * modules, since they have built-in fallbacks.\n   */\n  'DevLoadingView',\n  'EXDevLauncher',\n  'EXReactNativeEventEmitter',\n  'NativeUnimoduleProxy',\n  /**\n   * Other modules that are accessed via packages in the Expo SDK but have built-in fallbacks\n   */\n  'ExpoImageModule',\n  'ExpoRandom',\n  'PlatformLocalStorage',\n  'RNC_AsyncSQLiteDBStorage',\n  'RNCAsyncStorage',\n  'RNGetRandomValues',\n  'RNVectorIconsManager',\n  'RNVectorIconsModule',\n  // False alarm from lottie where it uses react-native-safe-module to detect corresponding native module, but it doesn't exist in lottie.\n  'LottieAnimationViewManager',\n  'LottieAnimationView',\n  /**\n   * Other methods that can be called on the NativeModules object that we should ignore. The\n   * underlying NativeModules object is sometimes a proxy itself so may not have these methods\n   * defined.\n   */\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toJSON',\n  'toLocaleString',\n  'toString',\n  'valueOf',\n  '$$typeof',\n]);\nconst alreadyErroredModules: Set<string> = new Set();\n\nlet additionalModulesToIgnore: Set<string> = new Set();\nlet enabled = true;\n\nfunction createErrorMessageForStoreClient(moduleName: string) {\n  return `Your JavaScript code tried to access a native module, ${moduleName}, that isn't supported in Expo Go.\nTo continue development with ${moduleName}, you need to create a development build of your app. See https://expo.fyi/missing-native-module for more info, including how to disable these errors.`;\n}\n\nfunction createErrorMessageForDevelopmentBuild(moduleName: string) {\n  return `Your JavaScript code tried to access a native module, ${moduleName}, that doesn't exist in this development build.\nMake sure you are using the newest available development build of this app and running a compatible version of your JavaScript code. If you've installed a new library recently, you may need to make a new development build.\nSee https://expo.fyi/missing-native-module for more info, including how to disable these errors.`;\n}\n\nexport function createProxyForNativeModules(NativeModules: any) {\n  if (!__DEV__) {\n    return NativeModules;\n  }\n  return new Proxy(NativeModules, {\n    get(target, prop, receiver) {\n      const value = Reflect.get(target, prop, receiver);\n      if (\n        enabled &&\n        typeof prop !== 'symbol' &&\n        (value === null || value === undefined) &&\n        !PROPS_TO_IGNORE.has(prop) &&\n        !additionalModulesToIgnore.has(prop) &&\n        !alreadyErroredModules.has(prop)\n      ) {\n        alreadyErroredModules.add(prop);\n\n        const isRunningInStoreClient =\n          global.expo?.modules?.NativeModulesProxy?.modulesConstants.ExponentConstants\n            ?.executionEnvironment === ExecutionEnvironment.StoreClient ||\n          target.NativeUnimoduleProxy?.modulesConstants.ExponentConstants?.executionEnvironment ===\n            ExecutionEnvironment.StoreClient;\n        if (isRunningInStoreClient) {\n          throw new Error(createErrorMessageForStoreClient(prop));\n        } else if (target.EXDevLauncher) {\n          throw new Error(createErrorMessageForDevelopmentBuild(prop));\n        }\n      }\n      return value;\n    },\n  });\n}\n\n/**\n * Disable the error thrown when trying to access a native module that doesn't exist in the host\n * runtime. If a module name or array of module names is provided, this method disables the error\n * for only those modules, erasing a previous setting if one exists. If no parameter is provided,\n * this method disables the error for all modules.\n *\n * @param moduleNames Name of module or modules for which to disable the missing native module\n * error. If this parameter is omitted, the error will be disabled globally.\n */\nexport function disableMissingNativeModuleErrors(moduleNames?: string[] | string) {\n  if (moduleNames) {\n    additionalModulesToIgnore =\n      typeof moduleNames === 'string' ? new Set([moduleNames]) : new Set(moduleNames);\n    enabled = true;\n  } else {\n    enabled = false;\n  }\n}\n\n/**\n * Access a native module without throwing an error if it doesn't exist.\n *\n * @param moduleName Name of module to access\n * @returns Corresponding native module object, or null if it doesn't exist\n */\nexport function getNativeModuleIfExists(moduleName: string): any {\n  return originalNativeModules[moduleName];\n}\n"]},"metadata":{},"sourceType":"module"}